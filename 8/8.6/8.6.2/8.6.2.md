> [8. Aplicaci√≥n de Patrones Arquitecturales](../../8.md) ‚Ä∫ [8.6. Listado Consolidado](../8.6.md) ‚Ä∫ [8.6.2. Patrones de Componente y Conector](8.6.2.md)

# 8.6.2. Patrones de Componente y Conector

## Patrones de Comunicaci√≥n entre Componentes

Esta secci√≥n documenta c√≥mo los componentes del sistema InnovaLogix interact√∫an entre s√≠, los patrones de comunicaci√≥n aplicados y las tecnolog√≠as utilizadas.

---

## 1. Request-Response (Cliente-Servidor)

**Aplicaci√≥n:**  
Comunicaci√≥n s√≠ncrona entre frontend React y backend Express mediante API REST.

**Componentes involucrados:**
- **Cliente:** Aplicaci√≥n React 19.2 (navegador)
- **Gateway:** API Gateway en puerto 3000 (enrutamiento)
- **Servicios:** 5 microservicios backend (puertos 3001-3005)
- **Protocolo:** HTTP/HTTPS con JSON

**Ejemplos de uso:**
- Frontend solicita lista de productos ‚Üí Gateway enruta a Inventory:3001 ‚Üí responde JSON
- Usuario procesa venta ‚Üí Gateway enruta a POS:3004 ‚Üí confirma transacci√≥n
- Usuario consulta reporte ‚Üí Gateway enruta a Reports:3005 ‚Üí genera datos

**Beneficios:**
- Simplicidad de implementaci√≥n
- Amplio soporte de herramientas (axios, fetch)
- Facilita debugging con DevTools

**Trade-offs:**
- Bloqueo del cliente durante respuesta
- No apto para operaciones de larga duraci√≥n

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama de secuencia Request-Response entre React y Express -->

---

## 2. Publish-Subscribe (WebSocket)

**Aplicaci√≥n:**  
Comunicaci√≥n en tiempo real mediante WebSocket usando Socket.IO 4.8.

**Componentes involucrados:**
- **Publishers:** Microservicios backend (Inventory, CRM, Purchases, POS)
- **Subscribers:** Frontend React (clientes conectados via Socket.IO client)
- **Tecnolog√≠a:** Socket.IO 4.8 (WebSocket + fallback)

**Eventos principales:**
- `stockUpdate`: Emitido por Inventory (3001), escuchado por frontend en m√≥dulos POS, Almac√©n
- `newCustomer`: Emitido por CRM (3002), escuchado por dashboard
- `purchaseCreated`: Emitido por Purchases (3003), escuchado por notificaciones
- `saleCompleted`: Emitido por POS (3004), escuchado por reportes en tiempo real

**Implementaci√≥n:**
- Cada servicio backend crea instancia Socket.IO con CORS configurado
- Frontend se conecta a cada servicio (ej: `socket-inventory`, `socket-crm`)
- Eventos emitidos con `io.emit()` llegan a todos los clientes conectados
- Latencia medida: <100ms desde emisi√≥n hasta recepci√≥n

**Beneficios:**
- Sincronizaci√≥n autom√°tica entre usuarios (<100ms)
- 0 requests innecesarios (vs polling cada 5s)
- Bidireccional (cliente puede emitir eventos)

**Trade-offs:**
- Conexiones persistentes consumen recursos
- Requiere manejo de reconexi√≥n autom√°tica
- Escalado horizontal requiere coordinaci√≥n (Redis adapter futuro)

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama mostrando Event Bus con m√∫ltiples publishers y subscribers -->

---

## 3. WebSocket (Comunicaci√≥n Bidireccional)

**Aplicaci√≥n:**  
Notificaciones en tiempo real del servidor al cliente usando Socket.IO.

**Casos de uso:**
- Notificar a terminales POS cuando stock se actualiza (evita vender productos agotados)
- Alertas en tiempo real de stock bajo m√≠nimo
- Notificaciones de √≥rdenes de compra aprobadas/rechazadas

**Componentes involucrados:**
- **Servidor WebSocket:** Socket.IO server en backend
- **Clientes:** Interfaces React conectadas v√≠a Socket.IO client
- **Canales:** Rooms por sucursal/terminal

**Beneficios:**
- Actualizaciones instant√°neas sin polling
- Conexi√≥n persistente reduce latencia
- Soporte bidireccional (servidor puede iniciar comunicaci√≥n)

**Trade-offs:**
- Mayor complejidad de implementaci√≥n
- Consumo de recursos del servidor (conexiones persistentes)
- Requiere manejo de reconexi√≥n

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama de WebSocket mostrando conexiones persistentes entre server y m√∫ltiples clientes -->

---

## 3. Database Access (PostgreSQL Pool)

**Aplicaci√≥n:**  
Comunicaci√≥n entre servicios backend y bases de datos PostgreSQL mediante connection pooling.

**Componentes involucrados:**
- **Servicios:** 6 microservicios (Gateway no tiene DB)
- **Connection Pools:** pg (node-postgres) con pool de 10 conexiones por servicio
- **Databases:** 5 instancias PostgreSQL independientes (puertos 5432-5436)
- **Queries:** Parametrizadas con placeholders ($1, $2, etc.)

**Patr√≥n de comunicaci√≥n:**
```
Service (Express routes) ‚Üí Business Logic ‚Üí PostgreSQL Pool ‚Üí Database
```

**Implementaci√≥n:**
- Cada servicio crea pool con `pg.Pool()` en `database.js`
- Pool reutiliza conexiones (evita overhead de crear/cerrar)
- Queries parametrizadas previenen SQL injection
- Transacciones ACID con BEGIN/COMMIT/ROLLBACK

**Beneficios:**
- Abstracci√≥n de conexiones (pool maneja ciclo de vida)
- Seguridad 100% (queries parametrizadas)
- Performance (reutilizaci√≥n de conexiones)

**Trade-offs:**
- Sin abstracci√≥n ORM (SQL manual)
- Requiere migraciones manuales

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama de capas mostrando flujo Service ‚Üí Repository ‚Üí ORM ‚Üí Database -->

---

## 4. API Gateway Pattern

**Aplicaci√≥n:**  
Gateway centralizado en puerto 3000 para enrutamiento y rate limiting.

**Componentes involucrados:**
- **Gateway:** Express 5.1 con express-rate-limit
- **Servicios backend:** 5 microservicios (Inventory, CRM, Purchases, POS, Reports)
- **Frontend:** React se comunica solo con Gateway

**Responsabilidades del Gateway:**
- **Enrutamiento:** Proxy con axios hacia servicios backend
- **Rate Limiting:** 100 requests/15 min por IP (express-rate-limit)
- **CORS:** Configurado una sola vez (simplifica frontend)
- **Health Check:** Endpoint `/health` para monitoreo

**Ejemplo de enrutamiento:**
- `GET localhost:3000/api/products` ‚Üí proxy a `Inventory:3001/api/products`
- `POST localhost:3000/api/sales` ‚Üí proxy a `POS:3004/api/sales`
- `GET localhost:3000/api/customers` ‚Üí proxy a `CRM:3002/api/customers`

**Beneficios:**
- Frontend solo conoce una URL base
- Protecci√≥n contra abuso (rate limiting)
- Facilita agregar autenticaci√≥n centralizada

**Trade-offs:**
- Single point of failure (mitigado con health checks)
- Latencia adicional (~10ms por proxy)

---

## Resumen de Conectores

| Tipo de Comunicaci√≥n | Tecnolog√≠a | Uso Principal | S√≠ncrono/As√≠nc |
|----------------------|-------------|---------------|---------------------|
| Request-Response | HTTP REST + JSON | Frontend-Backend | S√≠ncrono |
| Publish-Subscribe | Socket.IO 4.8 (WebSocket) | Notificaciones tiempo real | Bidireccional |
| Database Access | pg (node-postgres) + PostgreSQL | Persistencia de datos | S√≠ncrono |
| API Gateway | Express 5.1 + axios | Enrutamiento centralizado | S√≠ncrono |
| Cache | node-cache 5.1 | Optimizaci√≥n consultas | S√≠ncrono |

---

[‚¨ÖÔ∏è Anterior](../8.6.1/8.6.1.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../8.6.3/8.6.3.md)