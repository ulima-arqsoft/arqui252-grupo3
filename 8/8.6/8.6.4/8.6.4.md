> [8. AplicaciÃ³n de Patrones Arquitecturales](../../8.md) â€º [8.6. Listado Consolidado](../8.6.md) â€º [8.6.4. Patrones Cloud](8.6.4.md)

# 8.6.4. Patrones Cloud

## Patrones de Arquitectura Cloud-Native

Esta secciÃ³n documenta los patrones cloud aplicados en InnovaLogix para aprovechar las capacidades de infraestructura como servicio (IaaS/PaaS).

---

## 1. Serverless Frontend (Static Site Hosting)

**AplicaciÃ³n:**  
Frontend React desplegado como sitio estÃ¡tico en Vercel (serverless).

**CaracterÃ­sticas:**
- Sin servidores que mantener
- Escalado automÃ¡tico ilimitado
- Pago por uso (en plan Hobby es gratuito)
- Deploy instantÃ¡neo mediante CDN

**Ventajas:**
- Costo cero de infraestructura
- Alta disponibilidad (99.99% SLA)
- Performance excepcional (edge caching)
- Escalado automÃ¡tico ante trÃ¡fico

**Desventajas:**
- Vendor lock-in moderado (migraciÃ³n posible pero requiere esfuerzo)
- Menos control sobre configuraciÃ³n de servidores

---

## 2. Managed Services (Database-as-a-Service)

**AplicaciÃ³n:**  
PostgreSQL como servicio gestionado en Render.

**Beneficios de servicio gestionado:**
- Sin instalaciÃ³n ni configuraciÃ³n manual
- Backups automÃ¡ticos diarios
- Parches de seguridad aplicados automÃ¡ticamente
- Monitoreo integrado (CPU, memoria, queries)
- Escalado vertical con un clic

**Trade-offs:**
- Costo superior a database auto-gestionada
- Menos control sobre optimizaciones avanzadas
- Dependencia del proveedor

---

## 3. Health Check Pattern

**AplicaciÃ³n:**  
Endpoints de health check para monitoreo de disponibilidad.

**ImplementaciÃ³n:**

**Endpoint `/health`:**
- Verifica conectividad a base de datos
- Valida que servicios crÃ­ticos estÃ©n activos
- Retorna status 200 si todo OK, 503 si hay fallos

**Endpoint `/health/ready`:**
- Verifica si aplicaciÃ³n estÃ¡ lista para recibir trÃ¡fico
- Usado por load balancer para routing

**Monitoreo:**
- Render invoca `/health` cada 30 segundos
- Si 3 fallos consecutivos, marca instancia como unhealthy
- Load balancer deja de enviar trÃ¡fico a instancia unhealthy

---

## 4. Environment-based Configuration

**AplicaciÃ³n:**  
ConfiguraciÃ³n mediante variables de entorno (12-Factor App).

**Variables de entorno:**

**Backend (Render):**
- `DATABASE_URL`: ConexiÃ³n a PostgreSQL
- `JWT_SECRET`: Secreto para tokens de autenticaciÃ³n
- `SUNAT_API_KEY`: Credenciales SUNAT
- `SMTP_CONFIG`: ConfiguraciÃ³n de email
- `NODE_ENV`: production | development | test

**Frontend (Vercel):**
- `VITE_API_URL`: URL del backend
- `VITE_ENVIRONMENT`: prod | staging | dev

**Ventajas:**
- Mismo cÃ³digo funciona en mÃºltiples entornos
- Secretos no versionados en Git
- FÃ¡cil rotaciÃ³n de credenciales

---

## 5. Auto-Scaling Pattern

**AplicaciÃ³n:**  
Escalado horizontal automÃ¡tico del backend segÃºn mÃ©tricas.

**ConfiguraciÃ³n en Render:**
- **MÃ©trica:** CPU usage
- **Umbral de escalado UP:** CPU > 70% por 5 minutos
- **Umbral de escalado DOWN:** CPU < 30% por 10 minutos
- **MÃ­nimo de instancias:** 1
- **MÃ¡ximo de instancias:** 3

**Escenarios:**
- **TrÃ¡fico normal:** 1 instancia (costo $25/mes)
- **Pico de ventas (Black Friday):** Escala a 3 instancias automÃ¡ticamente
- **Madrugada:** Vuelve a 1 instancia

**Ventajas:**
- OptimizaciÃ³n de costos (paga solo por lo que usa)
- Alta disponibilidad durante picos
- Sin intervenciÃ³n manual

---

## 6. Immutable Infrastructure

**AplicaciÃ³n:**  
Deployments crean nuevas instancias en lugar de modificar existentes.

**Proceso de deployment:**
1. Render construye nueva imagen Docker del backend
2. Inicia nueva instancia con la imagen
3. Health check valida que nueva instancia funciona
4. Load balancer redirige trÃ¡fico a nueva instancia
5. Instancia anterior se apaga tras 30 segundos (graceful shutdown)

**Ventajas:**
- Zero-downtime deployments
- Rollback instantÃ¡neo (reiniciar instancia anterior)
- Consistencia (no hay "configuration drift")

---

## 7. Retry Pattern

**AplicaciÃ³n:**  
Reintentos automÃ¡ticos para llamadas a servicios externos (SUNAT, pasarelas de pago).

**ConfiguraciÃ³n:**
- **MÃ¡ximo de intentos:** 3
- **Backoff:** Exponencial (1s, 2s, 4s)
- **Timeout:** 10 segundos por intento
- **Errores retriables:** 5xx, timeout, network error
- **Errores no retriables:** 4xx (bad request)

**Ejemplo:**
Llamada a SUNAT API para validar RUC falla con timeout â†’ reintenta despuÃ©s de 1s â†’ falla nuevamente â†’ reintenta despuÃ©s de 2s â†’ Ã©xito.

**Ventajas:**
- Resiliencia ante fallos temporales de red
- Mejor experiencia de usuario (menos errores visibles)

---

## 8. Circuit Breaker Pattern (Propuesto)

**Estado actual:** No implementado  
**RecomendaciÃ³n:** Implementar para servicios externos crÃ­ticos

**Funcionamiento propuesto:**
- Si SUNAT API falla 5 veces consecutivas, abrir circuito
- Durante circuito abierto (5 minutos), no intentar llamadas
- Retornar error inmediato o usar fallback (cache)
- DespuÃ©s de 5 minutos, intentar una llamada de prueba
- Si Ã©xito, cerrar circuito; si falla, mantener abierto otros 5 minutos

**LibrerÃ­a recomendada:** `opossum` (Circuit Breaker para Node.js)

---

## Resumen de Patrones Cloud

| PatrÃ³n | Estado | Beneficio Principal | Herramienta |
|--------|--------|---------------------|-------------|
| Serverless Frontend | âœ… Implementado | Costo cero, alta disponibilidad | Vercel |
| Managed Database | âœ… Implementado | Sin mantenimiento manual | Render PostgreSQL |
| Health Checks | âœ… Implementado | DetecciÃ³n automÃ¡tica de fallos | Render |
| Environment Config | âœ… Implementado | SeparaciÃ³n de entornos | Variables de entorno |
| Auto-Scaling | âœ… Implementado | OptimizaciÃ³n de costos | Render |
| Immutable Infra | âœ… Implementado | Zero-downtime deploys | Render + Docker |
| Retry Pattern | âœ… Implementado | Resiliencia | axios-retry |
| Circuit Breaker | âš ï¸ Propuesto | ProtecciÃ³n ante cascading failures | (opossum) |

---

[â¬…ï¸ Anterior](../8.6.3/8.6.3.md) | [ðŸ  Home](../../../README.md)