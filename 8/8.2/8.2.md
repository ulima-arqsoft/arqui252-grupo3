# Patrones del Módulo Inventario

## **Decisión 1: Arquitectura de Microservicios**

**Patrón Utilizado:** Microservices Architecture

**Título:**  
Separación del módulo de inventario como microservicio independiente

**Contexto:**  
El sistema InnovaLogix maneja múltiples dominios de negocio (Inventario, CRM, Compras, POS, Reportes). Se requiere desarrollo, despliegue y escalado independiente de cada módulo sin afectar otros servicios.

**Alternativas:**
1. **Arquitectura Monolítica:**
   - Todo en una aplicación
   - Acoplamiento alto entre módulos
   - Despliegue monolítico
   - Escalado vertical limitado

2. **Arquitectura de Microservicios:**
   - Servicios independientes por dominio
   - Bajo acoplamiento
   - Despliegue independiente
   - Escalado horizontal

3. **Arquitectura Modular (Monolito Modular):**
   - Módulos separados en un solo proceso
   - Mejor que monolito tradicional
   - Sin independencia de despliegue

**Criterios de elección:**
- Independencia de despliegue
- Escalabilidad por servicio
- Resiliencia ante fallas
- Mantenibilidad modular

**Decisión:**
Arquitectura de Microservicios con 6 servicios independientes.

**Sustento:**  
El módulo de Inventario se implementa como microservicio independiente en puerto 3001 con su propia base de datos PostgreSQL (puerto 5433). Se comunica con otros servicios (CRM para notificaciones, POS para ventas, Purchases para reabastecimiento) mediante API REST y eventos WebSocket. Gateway centraliza enrutamiento en puerto 3000 con rate limiting. Esta separación permite escalar Inventory Service horizontalmente sin afectar CRM o POS, desplegar actualizaciones independientes, y aislar fallas. Cumple con principio de responsabilidad única y facilita mantenimiento por equipos separados.

---

## **Decisión 2: Patrón Layered Architecture (Capas)**

**Patrón Utilizado:** Layered Architecture (N-Tier)

**Título:**  
Organización del servicio de inventario en capas de responsabilidad

**Contexto:**  
El servicio de inventario requiere separación clara entre lógica de presentación (API endpoints), lógica de negocio (validaciones, cálculos) y acceso a datos (queries PostgreSQL). Se necesita mantenibilidad y testabilidad.

**Alternativas:**
1. **Script Transactions (todo en endpoints):**
   - Lógica mezclada en rutas
   - Difícil de testear
   - Código duplicado

2. **Layered Architecture:**
   - Capa de presentación (routes/endpoints)
   - Capa de lógica de negocio (validaciones)
   - Capa de acceso a datos (pool PostgreSQL)
   - Separación clara de responsabilidades

3. **Hexagonal Architecture:**
   - Puertos y adaptadores
   - Complejidad innecesaria para el alcance

**Criterios de elección:**
- Separación de responsabilidades
- Testabilidad por capa
- Simplicidad de implementación
- Mantenibilidad

**Decisión:**
Layered Architecture con 3 capas principales.

**Sustento:**  
El servicio se estructura en capas: **Presentación** (endpoints Express con rutas GET/POST/PUT/DELETE), **Lógica de negocio** (funciones como `saveNotification`, `refreshStockCache`, validaciones de stock), y **Acceso a datos** (pool de conexiones PostgreSQL con queries parametrizadas). Cache (node-cache) actúa como capa de optimización entre lógica y datos. WebSocket (Socket.IO) se integra en capa de presentación para notificaciones en tiempo real. Esta separación permite testear lógica de negocio sin base de datos (mocks), cambiar PostgreSQL por otra DB sin modificar endpoints, y agregar validaciones sin tocar queries. Facilita mantenimiento y cumple con principio de separación de concerns.

---

## **Decisión 3: Patrón API Gateway**

**Patrón Utilizado:** API Gateway Pattern

**Título:**  
Gateway centralizado para enrutamiento y rate limiting

**Contexto:**  
Frontend necesita acceder a 5 microservicios (Inventory, CRM, Purchases, POS, Reports). Solicitudes directas a cada servicio generan complejidad en configuración CORS, autenticación y control de tráfico.

**Alternativas:**
1. **Acceso directo frontend → servicios:**
   - Frontend conoce todas las URLs
   - CORS configurado en cada servicio
   - Sin control centralizado de tráfico

2. **API Gateway:**
   - Punto de entrada único (puerto 3000)
   - Enrutamiento a servicios backend
   - Rate limiting centralizado
   - CORS unificado

3. **Service Mesh:**
   - Comunicación servicio a servicio
   - Complejidad operacional alta

**Criterios de elección:**
- Simplicidad para frontend
- Control de tráfico centralizado
- Seguridad (rate limiting)
- Facilidad de configuración

**Decisión:**
API Gateway con Express y express-rate-limit.

**Sustento:**  
Gateway en puerto 3000 centraliza acceso a microservicios. Frontend hace requests a `localhost:3000/api/products` (enrutado a Inventory:3001), `localhost:3000/api/customers` (enrutado a CRM:3002), etc. Gateway implementa rate limiting con express-rate-limit (100 requests/15 min por IP) para prevenir abuso. CORS configurado una sola vez en Gateway. Proxy con axios hacia servicios backend. Esto simplifica configuración frontend (una sola URL base), protege servicios de sobrecarga, y permite agregar autenticación/logging centralizado en el futuro. Cumple con patrón de agregación y control de acceso.

---

## **Decisión 4: Patrón Database per Service**

**Patrón Utilizado:** Database per Service

**Título:**  
Base de datos PostgreSQL independiente para inventario

**Contexto:**  
Cada microservicio (Inventory, CRM, Purchases, POS, Reports) maneja su propio dominio de datos. Compartir una única base de datos genera acoplamiento entre servicios y riesgo de modificaciones cruzadas.

**Alternativas:**
1. **Base de datos compartida:**
   - Todos los servicios acceden mismas tablas
   - Alto acoplamiento
   - Riesgo de conflictos en schema

2. **Database per Service:**
   - Cada servicio con su propia DB
   - Independencia de datos
   - Sin interferencia entre servicios

3. **Shared Database con schemas separados:**
   - Schemas por servicio en misma DB
   - Acoplamiento a nivel de instancia

**Criterios de elección:**
- Independencia de datos
- Aislamiento de fallas
- Libertad de tecnología DB
- Escalabilidad independiente

**Decisión:**
Database per Service con PostgreSQL independiente.

**Sustento:**  
Inventory Service tiene su propia instancia PostgreSQL en puerto 5433 con tablas `products`, `inventory_movements`, `notifications`. CRM Service usa puerto 5434, Purchases usa 5435, etc. Esta separación permite modificar schema de inventario (agregar columnas, índices) sin afectar CRM o POS, escalar DB de inventario independientemente según carga, y elegir diferente motor DB en futuro si es necesario. Comunicación entre servicios mediante API REST (ej: Inventory llama a CRM para guardar notificaciones vía `POST /api/notifications`). Cumple con principio de autonomía de microservicios y previene acoplamiento de datos.

---
