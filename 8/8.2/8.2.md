> [8. Aplicaci√≥n de Patrones Arquitecturales](../8.md) ‚Ä∫ [8.2. M√≥dulo 2 / Integrante 2](8.2.md)

# 8.2. Patrones del M√≥dulo Inventario

## **Decisi√≥n 1: Patr√≥n Repository**

**T√≠tulo:**  
Abstracci√≥n del acceso a datos de inventario mediante Repository

**Contexto:**  
El m√≥dulo de Inventario gestiona productos, categor√≠as, stock por ubicaci√≥n, movimientos (entradas/salidas/ajustes) y niveles de reorden. Se requiere encapsular queries complejas (c√°lculo de stock disponible, productos bajo stock m√≠nimo, historial de movimientos) y permitir cambios en persistencia sin afectar l√≥gica de negocio.

**Alternativas:**
1. **Acceso directo con ORM:**
   - Servicios construyen queries Sequelize directamente
   - Queries duplicadas en m√∫ltiples lugares
   - Alto acoplamiento a PostgreSQL
   - Dificulta testing

2. **Patr√≥n Repository:**
   - Abstracci√≥n con interfaz de dominio
   - Repositories espec√≠ficos (ProductoRepository, MovimientoRepository)
   - Encapsulamiento de queries complejas
   - Facilita mocks para testing

3. **Data Mapper:**
   - Separaci√≥n completa dominio-persistencia
   - Complejidad innecesaria para el alcance

**Criterios de elecci√≥n:**
- **Encapsulamiento:** Ocultamiento de queries complejas
- **Testabilidad:** Simulaci√≥n en pruebas
- **Mantenibilidad:** Cambios en DB no afectan servicios
- **Expresividad:** M√©todos con lenguaje de dominio

**Decisi√≥n:**
Patr√≥n Repository.

- **Repositories:** ProductoRepository, MovimientoInventarioRepository, CategoriaRepository
- **Operaciones:** buscarProductosPorCategoria, calcularStockDisponible, obtenerProductosBajoStockMinimo
- **Encapsulamiento:** Joins complejos (productos + categor√≠as + ubicaciones + stock)

**Sustento:**  
Repository centraliza queries complejas como calcular stock disponible (suma entradas - salidas agrupado por producto y ubicaci√≥n) o buscar productos bajo stock m√≠nimo (joins entre productos, inventario y niveles de reorden). InventoryService se concentra en reglas de negocio en lugar de construcci√≥n de SQL. Cumple con QAW-08 (testabilidad) permitiendo simular repositories sin base de datos real.



## **Decisi√≥n 2: Patr√≥n Observer**

**T√≠tulo:**  
Notificaci√≥n de eventos de inventario mediante Observer

**Contexto:**  
Cambios en inventario (stock bajo m√≠nimo, nuevas entradas, ajustes) deben notificar a m√∫ltiples m√≥dulos: Compras (√≥rdenes de reabastecimiento), Reportes (m√©tricas de rotaci√≥n), CRM (disponibilidad de productos). Se requiere desacoplamiento entre emisor y receptores.

**Alternativas:**
1. **Llamadas directas:**
   - InventoryService invoca ComprasService, ReportesService, CRMService
   - Alto acoplamiento
   - Dificulta agregar observadores
   - Viola modularidad

2. **Patr√≥n Observer:**
   - InventoryService emite eventos
   - M√≥dulos se registran como observadores
   - Notificaci√≥n autom√°tica sin acoplamiento
   - Extensible

3. **Event Bus:**
   - Bus centralizado de eventos
   - Overhead innecesario para monolito

**Criterios de elecci√≥n:**
- **Desacoplamiento:** Independencia emisor-receptores
- **Extensibilidad:** Agregar observadores f√°cilmente
- **Simplicidad:** Adecuado para monolito
- **Consistencia:** Notificaci√≥n garantizada

**Decisi√≥n:**
Patr√≥n Observer.

- **Eventos:** StockBajoDetectado, EntradaMercanciaRegistrada, AjusteInventarioRealizado
- **Observadores:** ComprasObserver (genera √≥rdenes), ReportesObserver (actualiza m√©tricas), CRMObserver (notifica clientes)
- **Registro:** Observadores se suscriben en inicializaci√≥n

**Sustento:**  
Observer desacopla los efectos secundarios de cambios en inventario. Cuando stock cae bajo nivel de reorden (ej: carpas con m√≠nimo 5 y actual 3), se emite StockBajoDetectado. ComprasObserver genera orden de compra sugerida, ReportesObserver actualiza m√©tricas de rotaci√≥n. El m√≥dulo de Inventario se concentra en tracking de stock sin conocer reglas de reabastecimiento. Cumple con QAW-04 (mantenibilidad modular).


## **Decisi√≥n 3: Patr√≥n Specification**

**T√≠tulo:**  
B√∫squedas complejas de productos mediante Specification

**Contexto:**  
Usuarios necesitan buscar productos con criterios combinables: categor√≠a (carpas, sacos, mochilas), rango de precio, nivel de stock, proveedor, ubicaci√≥n, estado (activo/descontinuado). Criterios deben combinarse din√°micamente sin crear m√©todo para cada combinaci√≥n.

**Alternativas:**
1. **M√©todos espec√≠ficos:**
   - buscarPorCategoria(), buscarPorPrecio(), buscarPorCategoriaYPrecio()...
   - Explosi√≥n combinatoria
   - C√≥digo duplicado

2. **Patr√≥n Specification:**
   - Criterios encapsulados en clases
   - Composici√≥n con operadores (AND, OR, NOT)
   - Combinaci√≥n din√°mica
   - Query construida din√°micamente

3. **Query Builder con strings:**
   - Vulnerable a SQL injection
   - Acoplamiento a sintaxis SQL

**Criterios de elecci√≥n:**
- **Flexibilidad:** Combinaci√≥n din√°mica
- **Reusabilidad:** Criterios compartidos
- **Seguridad:** Protecci√≥n SQL injection
- **Mantenibilidad:** Agregar criterios f√°cilmente

**Decisi√≥n:**
Patr√≥n Specification.

- **Specifications:** ProductoPorCategoriaSpec, ProductoPorRangoPrecioSpec, ProductoBajoStockSpec
- **Operadores:** AndSpecification, OrSpecification, NotSpecification
- **Construcci√≥n:** Repository traduce specifications a WHERE SQL

**Sustento:**  
Specification permite b√∫squedas complejas sin explosi√≥n de m√©todos. Usuarios combinan criterios intuitivamente ("carpas entre $200-$500 bajo stock m√≠nimo del proveedor X"). Cada criterio es clase reutilizable, repository construye query din√°micamente. Agregar criterios (fecha de entrada, rating proveedor) no modifica c√≥digo existente. Cumple con QAW-05 (mantenibilidad) y protege contra SQL injection con queries parametrizadas.


---

[‚¨ÖÔ∏è Anterior](../8.1/8.1.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../8.3/8.3.md)