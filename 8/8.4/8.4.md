> [8. Aplicaci√≥n de Patrones Arquitecturales](../8.md) ‚Ä∫ [8.4. M√≥dulo 4 / Integrante 4](8.4.md)

# 8.4. Patrones del M√≥dulo Reportes

## **Decisi√≥n 1: Patr√≥n Query Object**

**T√≠tulo:**  
Construcci√≥n flexible de consultas de reportes mediante Query Object

**Contexto:**  
El m√≥dulo de Reportes genera m√∫ltiples consultas anal√≠ticas con filtros din√°micos: ventas por per√≠odo (d√≠a/semana/mes/a√±o), productos m√°s vendidos por categor√≠a, margen de ganancia por proveedor, rotaci√≥n de inventario por ubicaci√≥n. Los usuarios combinan filtros seg√∫n necesidad (fecha, categor√≠a, sucursal, usuario). Construir queries SQL manualmente es propenso a errores y SQL injection.

**Alternativas:**
1. **Queries SQL hardcodeadas:**
   - Una query por cada combinaci√≥n de filtros
   - Explosi√≥n de queries
   - Dificulta mantenimiento
   - Vulnerable a SQL injection

2. **Patr√≥n Query Object:**
   - Objeto que encapsula construcci√≥n de query
   - M√©todos fluent para agregar filtros (where, groupBy, orderBy)
   - Query construida din√°micamente
   - Queries parametrizadas

3. **ORM puro:**
   - Queries con Sequelize
   - Limitado para agregaciones complejas
   - Performance inferior para reportes anal√≠ticos

**Criterios de elecci√≥n:**
- **Flexibilidad:** Construcci√≥n din√°mica de queries
- **Seguridad:** Prevenci√≥n de SQL injection
- **Performance:** Optimizaci√≥n de consultas anal√≠ticas
- **Mantenibilidad:** Reutilizaci√≥n de l√≥gica de filtrado

**Decisi√≥n:**
Patr√≥n Query Object.

- **Clases:** SalesReportQuery, InventoryReportQuery, ProfitReportQuery
- **M√©todos fluent:** filterByDateRange(), filterByCategory(), groupByPeriod(), orderByTotal()
- **Construcci√≥n:** Traducci√≥n a SQL optimizado con CTEs y √≠ndices

**Sustento:**  
Query Object permite construir reportes complejos din√°micamente sin duplicar c√≥digo. SalesReportQuery puede filtrar por rango de fechas, agrupar por d√≠a/semana/mes y ordenar por total, generando SQL optimizado con Common Table Expressions. Los filtros se agregan seg√∫n necesidad del usuario sin requerir query diferente por cada combinaci√≥n. Usa queries parametrizadas previniendo SQL injection. Cumple con QAW-02 (performance) generando consultas optimizadas con √≠ndices apropiados.

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama de clases mostrando SalesReportQuery con m√©todos fluent y construcci√≥n de SQL -->

---

## **Decisi√≥n 2: Patr√≥n Materialized View**

**T√≠tulo:**  
Optimizaci√≥n de reportes frecuentes mediante Materialized View

**Contexto:**  
Reportes como "Top 10 productos vendidos del mes" y "Ventas diarias del a√±o" se consultan m√∫ltiples veces al d√≠a por gerencia. Calcular estas agregaciones en tiempo real desde tablas transaccionales (ventas, detalles_venta) es costoso en performance. QAW-02 requiere reportes en menos de 3 segundos.

**Alternativas:**
1. **Queries en tiempo real:**
   - Calcular agregaciones desde tablas transaccionales
   - Siempre datos actualizados
   - Alto costo computacional
   - No cumple requisito de performance

2. **Patr√≥n Materialized View:**
   - Tablas pre-calculadas con agregaciones
   - Actualizaci√≥n programada (cada hora/d√≠a)
   - Queries ultra r√°pidas
   - Datos ligeramente desactualizados (aceptable)

3. **Cache en memoria:**
   - Redis con agregaciones
   - Mayor complejidad de infraestructura
   - Datos vol√°tiles

**Criterios de elecci√≥n:**
- **Performance:** Tiempo de respuesta < 3 segundos
- **Simplicidad:** M√≠nima complejidad de implementaci√≥n
- **Consistencia eventual:** Tolerancia a datos no instant√°neos
- **Escalabilidad:** Soporte para crecimiento de datos

**Decisi√≥n:**
Patr√≥n Materialized View.

- **Vistas materializadas:** ventas_diarias_mv, productos_mas_vendidos_mv, margen_por_proveedor_mv
- **Actualizaci√≥n:** Job programado cada hora con refresh incremental
- **Consultas:** SELECT directo desde vistas (sin joins complejos)

**Sustento:**  
Materialized Views reducen tiempo de consulta de 15-20 segundos a menos de 1 segundo. ventas_diarias_mv pre-calcula totales diarios, productos_mas_vendidos_mv mantiene ranking actualizado cada hora. Para reportes gerenciales, datos con 1 hora de antig√ºedad son aceptables. PostgreSQL soporta materialized views nativamente con REFRESH CONCURRENTLY (sin bloquear lecturas). Cumple con QAW-02 (performance < 3 seg) sin requerir infraestructura adicional.

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama mostrando tablas transaccionales, job de actualizaci√≥n y materialized views para consultas r√°pidas -->

---

[‚¨ÖÔ∏è Anterior](../8.3/8.3.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../8.5/8.5.md)