> [9. Metodolog√≠a de Dise√±o de Arquitectura - Aplicaci√≥n de ADD](../../9.md) ‚Ä∫ [9.2. Iteraci√≥n 1: Definir la estructura general del sistema](../9.2.md) ‚Ä∫ [9.2.3. Conceptos de dise√±o](9.2.3.md)

# 9.2.3. Conceptos de dise√±o

## Conceptos de Dise√±o para la Estructura General del Sistema

Esta secci√≥n documenta los principales conceptos de dise√±o y decisiones arquitect√≥nicas tomadas para establecer la estructura general del sistema InnovaLogix Retail ERP.

### DEC-1: Arquitectura de Microservicios

**Concepto:** Estructura distribuida con 6 servicios independientes cada uno con su base de datos

**Decisi√≥n:** Implementar arquitectura de microservicios con API Gateway centralizado, 5 servicios de negocio (Inventory, CRM, Purchases, POS, Reports), y patr√≥n Database per Service.

**Justificaci√≥n:**
- Requisito acad√©mico para demostrar arquitecturas distribuidas
- Separaci√≥n de responsabilidades por dominio de negocio
- Escalabilidad independiente por servicio
- Permite deployment y desarrollo independiente
- Facilita mantenimiento de c√≥digo por boundaries claros

**Patrones aplicados:**
- Microservices Architecture
- API Gateway
- Database per Service
- Layered Architecture (por servicio)

---

### DEC-2: Comunicaci√≥n REST + WebSocket

**Concepto:** Comunicaci√≥n h√≠brida entre frontend-backend y entre servicios

**Decisi√≥n:** Implementar REST API para operaciones CRUD s√≠ncronas y Socket.IO para notificaciones en tiempo real.

**Justificaci√≥n:**
- REST para operaciones est√°ndares (GET, POST, PUT, DELETE)
- WebSocket para eventos en tiempo real (stock bajo, nuevo cliente, venta completada)
- Socket.IO maneja reconexi√≥n autom√°tica y fallback a long-polling
- Bidireccional: backend puede pushear eventos a frontend sin polling
- Est√°ndar ampliamente adoptado y documentado

**Endpoints dise√±ados:**
- Gateway: `/api/products/*`, `/api/customers/*`, `/api/suppliers/*`, `/api/sales/*`, `/api/reports/*`
- WebSocket events: `stockUpdate`, `newCustomer`, `purchaseCreated`, `saleCompleted`

---

### DEC-3: Base de Datos por Servicio (PostgreSQL)

**Concepto:** Cada servicio tiene su propia instancia PostgreSQL independiente

**Decisi√≥n:** Utilizar PostgreSQL 15 con patr√≥n Database per Service: 5 instancias en puertos 5432-5436, sin ORM (driver pg directo).

**Justificaci√≥n:**
- Independencia de datos por servicio (no acoplamiento en DB)
- Escalabilidad: cada DB puede optimizarse para su servicio
- Queries parametrizadas con pg previenen SQL injection (100% seguras)
- Integridad referencial dentro de cada servicio
- Backups y migraciones independientes por servicio

**Organizaci√≥n de datos:**
- inventory_db (puerto 5432): productos, stock, kardex
- crm_db (puerto 5433): clientes, puntos, reclamos
- purchases_db (puerto 5434): proveedores, √≥rdenes, precios
- pos_db (puerto 5435): ventas, detalles_venta
- reports_db (puerto 5436): datos agregados para analytics

---

### DEC-4: Stack Tecnol√≥gico JavaScript Full-Stack

**Concepto:** JavaScript/Node.js en todo el stack sin ORMs pesados

**Decisi√≥n:** React 19.2 (frontend) + Node.js/Express 5.1 (backend) + PostgreSQL con driver pg (sin Sequelize) + Socket.IO 4.8 + node-cache 5.1.

**Justificaci√≥n:**
- Un solo lenguaje (JavaScript) facilita mantenimiento
- React 19.2 con Vite 7.2 para build ultra-r√°pido
- Express 5.1 con mejoras de performance sobre 4.x
- pg (driver nativo) m√°s r√°pido y ligero que ORMs como Sequelize o TypeORM
- Socket.IO 4.8 con soporte para emisi√≥n a m√∫ltiples clientes
- node-cache para cache en memoria sin Redis externo

**Tecnolog√≠as complementarias:**
- jsPDF + jspdf-autotable para generaci√≥n de PDFs
- axios para HTTP requests
- lucide-react para iconograf√≠a moderna

---

### DEC-5: API Gateway con Rate Limiting

**Concepto:** Punto de entrada √∫nico para todos los servicios backend

**Decisi√≥n:** Implementar API Gateway en puerto 3000 con express-rate-limit (100 req/min por IP), CORS configurado, y enrutamiento basado en paths.

**Justificaci√≥n:**
- Centraliza autenticaci√≥n y rate limiting (no duplicar en cada servicio)
- Simplifica frontend: un solo endpoint (http://localhost:3000)
- Facilita monitoreo y logging centralizado
- Protecci√≥n contra DDoS b√°sico con rate limiting
- CORS configurado para permitir frontend en puerto 5173

**Reglas de enrutamiento:**
```
/api/products/* ‚Üí Inventory Service (3001)
/api/customers/* ‚Üí CRM Service (3002)
/api/suppliers/* ‚Üí Purchases Service (3003)
/api/sales/* ‚Üí POS Service (3004)
/api/reports/* ‚Üí Reports Service (3005)
```

---

### DEC-6: Cache en Memoria con node-cache

**Concepto:** Reducir carga en PostgreSQL cacheando datos frecuentemente consultados

**Decisi√≥n:** Implementar node-cache en servicios cr√≠ticos (Inventory) con TTL de 600s (10 min) y m√°ximo 500 keys.

**Justificaci√≥n:**
- Consultas de productos son muy frecuentes (cada venta, cada b√∫squeda)
- node-cache en memoria es >100x m√°s r√°pido que PostgreSQL
- No requiere infraestructura adicional (como Redis)
- TTL de 10 min balancea freshness vs hit rate
- Evita complejidad de distributed cache

**Estrategia de invalidaci√≥n:**
1. Cache hit: devuelve data desde memoria (<10ms)
2. Cache miss: consulta DB, almacena en cache
3. Al modificar producto (PUT/POST): invalidar cache manualmente (`cache.del(key)`)
4. TTL autom√°tico despu√©s de 10 min

---

### DEC-7: Notificaciones en Tiempo Real con Socket.IO

**Concepto:** Comunicaci√≥n as√≠ncrona mediante WebSocket para eventos en tiempo real

**Decisi√≥n:** Utilizar Socket.IO 4.8 en cada servicio backend para emitir eventos a todos los clientes frontend conectados.

**Justificaci√≥n:**
- Desacoplamiento: servicios emiten eventos sin conocer qui√©n escucha
- Push notification: backend inicia comunicaci√≥n (no polling del frontend)
- Latencia <100ms para notificaciones cr√≠ticas (stock bajo, nuevo reclamo)
- Manejo autom√°tico de reconexi√≥n y heartbeat
- Rooms para filtrado (ej: solo usuarios de almac√©n reciben alerts de stock)

**Eventos principales:**
- `stockUpdate` ‚Üí Inventory emite al actualizar stock
- `newCustomer` ‚Üí CRM emite al registrar cliente
- `purchaseCreated` ‚Üí Purchases emite al confirmar orden
- `saleCompleted` ‚Üí POS emite al finalizar venta


---

### DEC-9: Deployment Local Multi-Proceso

**Concepto:** Ejecutar cada servicio en proceso Node.js separado

**Decisi√≥n:** Cada servicio se inicia independientemente con `node server.js` en su propio proceso, sin Docker ni Kubernetes.

**Justificaci√≥n:**
- Simplicidad para desarrollo acad√©mico
- Debugging m√°s directo (logs en terminales separadas)
- Sin overhead de containers
- Permite reiniciar servicios individualmente sin afectar otros
- Facilita desarrollo paralelo (cada dev trabaja en un servicio)

**Scripts de inicio:**
- Gateway: `cd services/gateway && node server.js`
- Inventory: `cd services/inventory-service && node server.js`
- CRM: `cd services/crm-service && node server.js`
- Purchases: `cd services/purchases-service && node server.js`
- POS: `cd services/pos-service && node server.js`
- Reports: `cd services/reports-service && node server.js`
- Frontend: `cd frontend && npm run dev`

---

### Resumen de Decisiones

| ID | Decisi√≥n | Patr√≥n/Tecnolog√≠a | Impacto |
|----|----------|-------------------|---------|
| DEC-1 | Arquitectura de Microservicios | Microservices + API Gateway | Alto |
| DEC-2 | REST + WebSocket | REST API + Socket.IO 4.8 | Alto |
| DEC-3 | Database per Service | PostgreSQL √ó 5 (pg driver) | Alto |
| DEC-4 | Stack JavaScript Full-Stack | React 19.2 + Node.js + Express 5.1 | Alto |
| DEC-5 | API Gateway | express-rate-limit | Alto |
| DEC-6 | Cache en Memoria | node-cache 5.1 | Medio |
| DEC-7 | WebSocket | Socket.IO 4.8 | Medio |
| DEC-8 | Deployment Local | Multi-proceso sin Docker | Bajo |

---

[‚¨ÖÔ∏è Anterior](../9.2.2/9.2.2.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../9.2.4/9.2.4.md)