> [9. Metodolog√≠a de Dise√±o de Arquitectura - Aplicaci√≥n de ADD](../../9.md) ‚Ä∫ [9.2. Iteraci√≥n 1: Definir la estructura general del sistema](../9.2.md) ‚Ä∫ [9.2.5. Vistas y Decisiones](9.2.5.md)

# 9.2.5. Vistas y Decisiones

## An√°lisis de las Vistas Arquitect√≥nicas y las Decisiones

Esta secci√≥n analiza c√≥mo las decisiones tomadas en la iteraci√≥n 1 satisfacen los requisitos de calidad y requisitos funcionales del sistema InnovaLogix.

---

## 1. An√°lisis de Requisitos de Calidad

### QAW-01: Disponibilidad (Modo Offline POS)

**Escenario:** Durante una ca√≠da de internet (30 min promedio), el POS debe continuar registrando ventas sin p√©rdida de datos ni degradaci√≥n significativa de funcionalidad.

**Decisiones que lo soportan:**
- **DEC-6: Soporte Offline mediante PWA** - Service Workers cachean la app y datos cr√≠ticos
- **DEC-1: Arquitectura Monol√≠tica Modular** - Todos los m√≥dulos en misma app facilita sincronizaci√≥n offline

**An√°lisis:**
- **Fortalezas:**
  - IndexedDB almacena ventas localmente hasta recuperar conexi√≥n
  - Service Workers permiten funcionamiento sin red
  - Cola de sincronizaci√≥n autom√°tica al reconectar
  - UX consistente (offline indicators claros)
  
- **Riesgos:**
  - Conflictos si m√∫ltiples terminales editan el mismo producto
  - Limitaci√≥n de 50MB en IndexedDB (Chrome/Edge)
  - Sin validaci√≥n en tiempo real de stock (puede vender producto agotado)
  
- **Mitigaciones:**
  - Estrategia "√∫ltima escritura gana" para conflictos menores
  - Alertas visuales cuando se opera offline
  - Validaci√≥n de stock al reconectar y rollback si aplica
  - Compresi√≥n de datos en IndexedDB (JSON.stringify)

**M√©tricas de √©xito:**
- Latencia de escritura en IndexedDB: <50ms
- Tasa de sincronizaci√≥n exitosa: >98%
- Tiempo de recuperaci√≥n post-reconexi√≥n: <10s

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama de flujo de sincronizaci√≥n offline mostrando cola de operaciones, reconexi√≥n y resoluci√≥n de conflictos -->

---

### QAW-02: Rendimiento (Tiempo de respuesta b√∫squeda)

**Escenario:** En la b√∫squeda de productos del POS con cat√°logo de 5,000+ productos, el autocompletado debe responder en <200ms para el 95% de las b√∫squedas.

**Decisiones que lo soportan:**
- **DEC-3: PostgreSQL con √çndices** - √çndices GIN/GIST en campos textuales
- **DEC-2: API REST con Caching** - Redis para cacheo de productos m√°s buscados
- **DEC-4: React con optimizaci√≥n** - Debouncing en b√∫squeda (300ms)

**An√°lisis:**
- **Fortalezas:**
  - √çndices full-text en PostgreSQL (`CREATE INDEX ON productos USING GIN(to_tsvector('spanish', nombre))`)
  - Redis cachea top 100 productos (80% hit rate estimado)
  - Paginaci√≥n en API (limit 20 resultados)
  - Debouncing reduce llamadas innecesarias
  
- **Riesgos:**
  - PostgreSQL puede ser lento con b√∫squedas complejas (m√∫ltiples filtros)
  - Redis consume memoria adicional (~50MB para cache)
  - Sin CDN inicial, latencia depende de Render
  
- **Mitigaciones:**
  - Query optimization: `EXPLAIN ANALYZE` en queries cr√≠ticas
  - Cache warming al inicio del d√≠a (pre-cacheo de productos frecuentes)
  - Lazy loading de im√°genes de productos
  - Considerar ElasticSearch si cat√°logo crece >20K productos

**M√©tricas de √©xito:**
- P95 latency b√∫squeda: <200ms
- P99 latency b√∫squeda: <500ms
- Tasa de cache hit: >75%

<!-- INSERTAR IMAGEN ACERCA DE: Gr√°fico de distribuci√≥n de latencias de b√∫squeda con percentiles 50, 95, 99 -->

---

### QAW-03: Seguridad (Autenticaci√≥n y Autorizaci√≥n)

**Escenario:** Solo usuarios con rol "Administrador" o "Almacenero" pueden ajustar stock manualmente. Intentos no autorizados deben ser registrados y rechazados.

**Decisiones que lo soportan:**
- **DEC-8: JWT con refresh tokens** - Autenticaci√≥n stateless segura
- **DEC-9: RBAC granular** - Permisos por rol y recurso
- **DEC-11: Logging y Auditor√≠a** - Registro de todos los intentos

**An√°lisis:**
- **Fortalezas:**
  - JWT firma digitalmente (HMAC SHA-256) previene modificaci√≥n
  - Access token corto (15 min) limita ventana de exposici√≥n
  - Refresh token en httpOnly cookie previene XSS
  - Middleware RBAC valida en cada request protegido
  - Tabla auditoria registra qui√©n, qu√©, cu√°ndo
  
- **Riesgos:**
  - JWT no puede revocarse f√°cilmente (hasta expiraci√≥n)
  - Sin MFA inicial, contrase√±as comprometidas exponen sistema
  - Sin rate limiting inicial en login (posible brute force)
  
- **Mitigaciones:**
  - Blacklist de tokens revocados en Redis (para casos cr√≠ticos)
  - Pol√≠tica de contrase√±as fuertes (8+ chars, may√∫scula, n√∫mero, s√≠mbolo)
  - Implementar rate limiting (express-rate-limit) en endpoints de auth
  - Planificar MFA con TOTP (Google Authenticator) en Fase 2

**M√©tricas de √©xito:**
- 100% de operaciones cr√≠ticas auditadas
- 0 accesos no autorizados exitosos
- Tiempo de detecci√≥n de intento malicioso: <1s

<!-- INSERTAR IMAGEN ACERCA DE: Flujo de autenticaci√≥n mostrando login, generaci√≥n de tokens, refresh, y validaci√≥n en cada request -->

---

### QAW-04: Usabilidad (Aprendizaje para cajeros)

**Escenario:** Un nuevo cajero sin experiencia previa debe poder completar su primera venta en <5 minutos con entrenamiento m√≠nimo (10 min tutorial).

**Decisiones que lo soportan:**
- **DEC-4: React con UI consistente** - Componentes reutilizables, dise√±o coherente
- **DEC-2: API REST intuitiva** - Endpoints con nombres descriptivos

**An√°lisis:**
- **Fortalezas:**
  - Interfaz POS minimalista (m√°ximo 3 pasos para venta b√°sica)
  - Flujo guiado con validaci√≥n en tiempo real
  - Tooltips contextuales en campos complejos
  - Atajos de teclado (F2 buscar, F8 pagar, ESC cancelar)
  - Mensajes de error claros y accionables
  
- **Riesgos:**
  - Sin tutorial interactivo inicial (solo documentaci√≥n)
  - Curva de aprendizaje en funciones avanzadas (descuentos, combos)
  - Sin modo "entrenamiento" que no afecte datos reales
  
- **Mitigaciones:**
  - Onboarding tour con library react-joyride (5 pasos)
  - Modo demo con datos ficticios para pr√°ctica
  - Documentaci√≥n visual (screenshots) en wiki interna
  - Hotkeys hints visible en interfaz

**M√©tricas de √©xito:**
- Tiempo promedio primera venta: <4 min
- Tasa de error en primeras 10 ventas: <10%
- Satisfacci√≥n de usuario (SUS score): >70

<!-- INSERTAR IMAGEN ACERCA DE: Wireframe de interfaz POS con anotaciones de elementos clave y flujo de 3 pasos -->

---

### QAW-05: Mantenibilidad (Modularidad del c√≥digo)

**Escenario:** Agregar un nuevo m√©todo de pago (ej: billetera digital) debe tomar <8 horas de desarrollo sin afectar otros m√≥dulos.

**Decisiones que lo soportan:**
- **DEC-5: Modularizaci√≥n por dominio** - M√≥dulos independientes con fronteras claras
- **DEC-7: Event-driven** - Bajo acoplamiento entre m√≥dulos
- **DEC-10: Validaci√≥n en capas** - Separaci√≥n de responsabilidades

**An√°lisis:**
- **Fortalezas:**
  - Patr√≥n Strategy para m√©todos de pago (f√°cil extensi√≥n)
  - PaymentService con interfaz definida (`processPayment(method, amount)`)
  - Eventos `PaymentProcessed` desacoplados de l√≥gica de negocio
  - Estructura de carpetas clara por m√≥dulo
  
- **Riesgos:**
  - Sin pruebas unitarias exhaustivas (cobertura <60% inicialmente)
  - Dependencias impl√≠citas no documentadas
  - Sin arquitectura hexagonal completa (adaptadores limitados)
  
- **Mitigaciones:**
  - Documentar interfaces de cada servicio (JSDoc)
  - Aumentar cobertura de tests a >80% en Fase 2
  - Implementar dependency injection con Awilix
  - Diagrama de dependencias entre m√≥dulos en wiki

**M√©tricas de √©xito:**
- Tiempo de desarrollo nueva feature: <8h
- Bugs introducidos por cambio: <2 por sprint
- Cobertura de tests cr√≠ticos: >70%

<!-- INSERTAR IMAGEN ACERCA DE: Diagrama de dependencias entre m√≥dulos mostrando bajo acoplamiento y puntos de extensi√≥n -->

---

## 2. An√°lisis de Requisitos Funcionales

### RF-01: Registro de ventas multiproducto

**Implementaci√≥n:**
- Modelo `Venta` con relaci√≥n one-to-many a `DetalleVenta`
- Carrito en memoria (React state) con operaciones: add, remove, update quantity
- Endpoint `POST /api/sales` crea venta y detalles en transacci√≥n at√≥mica

**Validaciones:**
- Stock disponible para cada producto (validaci√≥n backend)
- Precio unitario no modificable manualmente (seguridad)
- Total calculado autom√°ticamente (subtotal + impuestos - descuentos)

**Cobertura:** ‚úÖ Completa

---

### RF-02: Control de inventario en tiempo real

**Implementaci√≥n:**
- Triggers en PostgreSQL actualizan stock tras venta/compra
- EventBus notifica cambios: `events.emit('StockUpdated', {producto_id, nueva_cantidad})`
- WebSockets (Socket.io) propagan cambios a terminales conectadas

**Validaciones:**
- Validaci√≥n de stock antes de confirmar venta
- Alertas autom√°ticas cuando stock < stock_m√≠nimo
- Kardex registra todos los movimientos con timestamp

**Cobertura:** ‚úÖ Completa

---

### RF-03: Generaci√≥n de comprobantes (boleta/factura)

**Implementaci√≥n:**
- `ReceiptService.generatePDF(venta)` usa pdfmake
- Plantilla con logo, datos fiscales, QR (futuro SUNAT)
- Storage en Render filesystem (`/tmp/comprobantes/`)

**Validaciones:**
- Numeraci√≥n correlativa autom√°tica por serie
- Datos de cliente obligatorios para facturas
- PDF generado en <2s

**Cobertura:** ‚ö†Ô∏è Parcial (falta integraci√≥n SUNAT para facturas electr√≥nicas)

---

### RF-04: Reportes de ventas y compras

**Implementaci√≥n:**
- `ReportService` con queries agregadas (SUM, AVG, GROUP BY)
- Filtros por fecha, producto, categor√≠a, proveedor
- Exportaci√≥n a PDF (pdfmake) y Excel (exceljs)

**Validaciones:**
- Rango de fechas m√°ximo: 1 a√±o (evitar queries lentos)
- Paginaci√≥n en reportes grandes (>1000 filas)
- Cach√© de reportes frecuentes (√∫ltimos 7 d√≠as) por 1 hora

**Cobertura:** ‚úÖ Completa

---

### RF-05: Gesti√≥n de clientes y programa de lealtad

**Implementaci√≥n:**
- CRUD de clientes con validaci√≥n de DNI/RUC
- Acumulaci√≥n autom√°tica: 1 punto por cada S/10 gastados
- Canje de puntos: 100 puntos = S/10 descuento

**Validaciones:**
- DNI/RUC √∫nico por cliente
- Puntos no negativos
- Auditor√≠a de movimientos de puntos

**Cobertura:** ‚úÖ Completa

---

## 3. Trade-offs Principales

### Trade-off 1: Monolito vs Microservicios

**Decisi√≥n:** Monolito modular (DEC-1)

**Pros:**
- Despliegue simple (single deploy)
- Desarrollo m√°s r√°pido (no hay complejidad de red)
- Debugging m√°s sencillo (stack traces completos)
- Transacciones ACID nativas en DB

**Contras:**
- Escalado vertical (toda app debe escalar)
- Fallo en un m√≥dulo puede afectar a todos
- Mayor acoplamiento temporal
- Dificulta distribuci√≥n geogr√°fica

**Justificaci√≥n:** Para un equipo de 3-5 devs y volumen inicial (<50K ventas/mes), el monolito reduce complejidad operacional significativamente. Plan de migraci√≥n a microservicios en Fase 3 (12+ meses) cuando escalado demande.

---

### Trade-off 2: JWT Stateless vs Sessions Stateful

**Decisi√≥n:** JWT con refresh tokens (DEC-8)

**Pros:**
- Stateless: backend no mantiene sesiones en memoria
- Escalable horizontalmente (no necesita sesiones compartidas)
- Funciona nativamente con apps m√≥viles futuras
- Reduce carga en DB (no consulta usuario cada request)

**Contras:**
- No puede revocarse f√°cilmente (hasta expiraci√≥n)
- Tama√±o de token mayor (payload incluido)
- Riesgo si secret key se compromete

**Justificaci√≥n:** Scalability > revocaci√≥n inmediata. Para casos cr√≠ticos (usuario comprometido), se implementa blacklist en Redis con TTL igual a exp del token.

---

### Trade-off 3: PostgreSQL vs MongoDB

**Decisi√≥n:** PostgreSQL (DEC-3)

**Pros:**
- ACID garantizado (cr√≠tico para ventas/inventario)
- Joins eficientes (reportes complejos)
- Amplia experiencia en equipo
- Herramientas de migraci√≥n maduras (Sequelize)

**Contras:**
- Schema r√≠gido (cambios requieren migrations)
- Menos flexible para datos no estructurados (encuestas)
- Escalado horizontal complejo (vs sharding en Mongo)

**Justificaci√≥n:** Retail ERP necesita integridad transaccional rigurosa. Datos altamente relacionados (ventas-clientes-productos) benefician de modelo relacional. Para datos no estructurados (encuestas), se usa JSONB en Postgres.

---

### Trade-off 4: SSR (Next.js) vs SPA (React+Vite)

**Decisi√≥n:** SPA con React+Vite (DEC-4 impl√≠cito)

**Pros:**
- Experiencia de usuario m√°s fluida (no reloads)
- Menos carga en servidor (toda la UI en cliente)
- Facilita modo offline (PWA)
- Build time m√°s r√°pido (Vite)

**Contras:**
- SEO limitado (no cr√≠tico para app interna)
- First load m√°s lento (bundle inicial ~800KB)
- Sin beneficios de streaming (Suspense en SSR)

**Justificaci√≥n:** InnovaLogix es app interna (no necesita SEO). PWA requiere SPA. Performance de navegaci√≥n interna > first load.

---

## 4. Riesgos Arquitect√≥nicos Identificados

| ID | Riesgo | Probabilidad | Impacto | Mitigaci√≥n |
|----|--------|--------------|---------|------------|
| R1 | P√©rdida de datos en sincronizaci√≥n offline | Media | Alto | Implementar cola persistente con retry exponencial, logs detallados |
| R2 | Degradaci√≥n de performance con +10K productos | Alta | Medio | √çndices optimizados, paginaci√≥n, caching agresivo |
| R3 | Compromiso de JWT secret | Baja | Cr√≠tico | Rotaci√≥n de secrets cada 90 d√≠as, vault para secrets |
| R4 | Fallo en generaci√≥n de PDF bloquea venta | Baja | Alto | Generaci√≥n as√≠ncrona, queue con fallback a env√≠o por email |
| R5 | Acoplamiento entre m√≥dulos aumenta con el tiempo | Alta | Medio | Code reviews estrictos, architecture decision log, refactors cada 6 meses |

---

## 5. Conclusiones de la Iteraci√≥n 1

### Objetivos Cumplidos ‚úÖ
1. ‚úÖ Estructura general del sistema definida (5 m√≥dulos + transversales)
2. ‚úÖ Decisiones arquitect√≥nicas fundamentales tomadas (DEC-1 a DEC-12)
3. ‚úÖ Elementos concretos instanciados (componentes, modelos, APIs)
4. ‚úÖ Requisitos de calidad analizados y validados
5. ‚úÖ Trade-offs documentados con justificaciones

### Objetivos Pendientes para Iteraci√≥n 2 üîÑ
1. Refinar m√≥dulo de Reportes: definir dashboard con m√©tricas en tiempo real
2. Detallar integraci√≥n con APIs externas (SUNAT, pasarelas de pago)
3. Optimizar estrategia de caching (Redis layers)
4. Dise√±ar arquitectura de monitoreo (Prometheus + Grafana)

### Pr√≥ximos Pasos
- **Iteraci√≥n 2** (Secci√≥n 9.3): Foco en m√≥dulo de Reportes y CRM con mayor detalle
- **Iteraci√≥n 3** (Secci√≥n 9.4): Integraci√≥n de servicios externos y observabilidad
- Validaci√≥n con stakeholders de decisiones cr√≠ticas (especialmente offline y seguridad)

---

[‚¨ÖÔ∏è Anterior](../9.2.4/9.2.4.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../9.1.6/9.1.6.md)