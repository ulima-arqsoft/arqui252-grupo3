# 5.2. Módulo 2 / Integrante 2 – Inventario

## ESC-13 – Táctica de Rendimiento

| Cod Escenario | Atributo de Calidad | Estímulo | Fuente del Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta |
|---------------|---------------------|----------|---------------------|-----------|---------|-----------|---------------------|
| ESC-13 | Rendimiento | Usuario busca productos en catálogo de 10k items | Usuario de Almacén / POS | Consulta de productos (GET /api/products) | Operación normal | Resultados aparecen en <1s desde cache | Tiempo < 1s, Hit rate ~75% |

### Táctica Elegida
**Cache-Aside Pattern con node-cache**

### Título
Cache-Aside vs Consulta directa a DB para mejorar rendimiento en consultas de inventario

### Contexto
Durante la operación normal, la lista de productos es consultada frecuentemente por múltiples usuarios desde el módulo de Almacén y POS. Las consultas directas a PostgreSQL generan latencia innecesaria.

### Alternativas
1. **Cache-Aside con node-cache**: almacenar lista en memoria con TTL de 10 minutos
2. **Consulta directa a DB**: sin cache, cada request va a PostgreSQL
3. **Cache distribuido con Redis**: cache compartido entre instancias

### Criterios de Elección
- Tiempo de respuesta
- Reducción de carga en DB
- Facilidad de implementación

### Decisión
Se adopta **Cache-Aside con node-cache**.

### Sustento
Reduce consultas a DB en ~70% (medido: 1 MISS, 3 HITs = 75% hit rate). TTL de 10 minutos balancea frescura de datos con performance. Invalidación automática en operaciones de escritura (crear/actualizar/eliminar productos) garantiza consistencia.

---

## ESC-18 – Táctica de Confiabilidad

| Cod Escenario | Atributo de Calidad | Estímulo | Fuente del Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta |
|---------------|---------------------|----------|---------------------|-----------|---------|-----------|---------------------|
| ESC-18 | Confiabilidad | Usuario actualiza inventario y se cae conexión | Usuario de Almacén | Actualización de stock | Operación normal | Cambios se guardan al reconectar | Transacciones atómicas, 0% pérdida de datos |

### Táctica Elegida
**Transacciones ACID con PostgreSQL**

### Título
Transacciones ACID vs Actualizaciones sin garantía para confiabilidad en caídas de conexión

### Contexto
Durante actualizaciones de inventario, si la conexión se cae a mitad de la operación, los cambios deben persistir correctamente sin pérdida de datos ni inconsistencias.

### Alternativas
1. **Transacciones SQL con BEGIN/COMMIT/ROLLBACK**: garantía de atomicidad
2. **Actualizaciones directas sin transacción**: sin garantía de consistencia
3. **Queue con reintentos**: operaciones en cola con procesamiento asíncrono

### Criterios de Elección
- Garantía de persistencia
- Prevención de inconsistencias
- Simplicidad de implementación

### Decisión
Se adopta **Transacciones ACID con PostgreSQL**.

### Sustento
En endpoint `/api/inventory/update-stock` se usa transacción explícita: `BEGIN` → validar stock → actualizar `products.stock` → registrar `inventory_movements` → `COMMIT`. Si falla por pérdida de conexión, PostgreSQL hace ROLLBACK automático. Cliente reintenta request y transacción se ejecuta completa. Garantiza 0% pérdida de datos.

---

## ESC-19 – Táctica de Disponibilidad/Interoperabilidad

| Cod Escenario | Atributo de Calidad | Estímulo | Fuente del Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta |
|---------------|---------------------|----------|---------------------|-----------|---------|-----------|---------------------|
| ESC-19 | Disponibilidad | Cambio de stock en inventario | Operaciones CRUD en productos | Sistema de notificaciones | Operación normal | Todos los usuarios conectados reciben actualización | Notificación en <100ms, 100% usuarios sincronizados |

### Táctica Elegida
**Event-Driven Architecture con WebSocket (Socket.IO) + Persistencia en DB**

### Título
Notificaciones en Tiempo Real vs Polling para sincronización de inventario

### Contexto
Cuando un usuario modifica stock (crear/actualizar/eliminar productos), otros usuarios en diferentes módulos (POS, Almacén, Reportes) necesitan ver los cambios inmediatamente sin recargar página. Sistema multi-usuario requiere sincronización en tiempo real.

### Alternativas
1. **WebSocket con Socket.IO + persistencia**: eventos en tiempo real con historial en DB
2. **Polling periódico**: frontend consulta API cada X segundos
3. **Server-Sent Events (SSE)**: unidireccional servidor → cliente

### Criterios de Elección
- Latencia de notificación
- Carga en servidor
- Persistencia de notificaciones
- Bidireccionalidad

### Decisión
Se adopta **WebSocket (Socket.IO) con persistencia en DB**.

### Sustento
Cada operación CRUD en inventario emite evento `stockUpdate`