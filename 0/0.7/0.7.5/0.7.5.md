> [0. Acerca del Grupo](../../0.md) ‚Ä∫ [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) ‚Ä∫ [0.7.5. Integrante 5](0.7.5.md)

# 0.7.5. Integrante 5-ALVARO SALAZAR 

Demo de Arquitectura CQRS 

1. ¬øQu√© es CQRS?

CQRS (Command Query Responsibility Segregation) es un patr√≥n arquitect√≥nico que separa la lectura y la escritura de datos en un sistema.

En una aplicaci√≥n tradicional, el mismo servicio se encarga tanto de modificar los datos (por ejemplo, registrar una venta) como de consultarlos (por ejemplo, mostrar reportes).
Con CQRS, se crean dos flujos independientes:
-Command (Comando): realiza acciones que cambian la informaci√≥n (crear, actualizar, eliminar).
-Query (Consulta): obtiene informaci√≥n sin modificarla.

Esta separaci√≥n mejora el rendimiento, la escabilidad y la organizaci√≥n del sistema.

2. Objetivo de la demo

La demo implementa el patr√≥n CQRS dentro del contexto del sistema InnovaLogix Retail ERP, mostrando c√≥mo se pueden separar las operaciones de escritura (Commands) y lectura (Queries) para lograr un flujo m√°s eficiente y escalable.

El proyecto se realiz√≥ usando contenedores Docker con Node.js y PostgreSQL.

3. Preparaci√≥n del entorno

Para ejecutar la demo, se configur√≥ un entorno local con las siguientes herramientas y componentes:

| Herramienta                  | Uso                                                                 |
| ---------------------------- | ------------------------------------------------------------------- |
|    Docker Desktop            | Ejecuci√≥n de contenedores para toda la arquitectura.                |
|    PostgreSQL                | Base de datos principal, con esquemas `write` y `read`.             |
|    Node.js                   | Entorno de ejecuci√≥n para los servicios Command, Query y Projector. |
|    Docker Compose            | Coordinaci√≥n y conexi√≥n de los tres servicios con la base de datos. |
|    Git Bash / PowerShell     | Terminal para ejecutar los comandos y probar los endpoints.         |


Estructura de la demo (En Visual Studio): 
<img width="385" height="661" alt="image" src="https://github.com/user-attachments/assets/7c844845-193f-4d5a-878e-2aba6fc1e96e" />

4. Que hice en el codigo:
   a) Definimos los modelos de datos:
        -write.* para las operaciones reales (ventas, stock, compras, outbox_events).
        -read.* para las consultas r√°pidas (stock_view, sales_daily).
   b)Command API :
       -Endpoints /ventas y /compras.
       -Cada acci√≥n guarda un registro y genera un evento en la tabla write.outbox_events.
   c)Projector:
       -Toma los eventos del outbox (por ejemplo, SaleCreated o PurchaseReceived).
       -Actualiza las tablas del esquema read con los nuevos datos.
   d)Query API:
      -Permite consultar la informaci√≥n lista para reportes.
      -Endpoints /stock/:sku y /dashboard/ventas/hoy.

   5) Demostracion del codigo:
     a) <img width="542" height="73" alt="image" src="https://github.com/user-attachments/assets/e04a6947-3978-4258-8f3c-972663bec281" />
      Le estoy pidiendo a mi Query API que me diga cu√°l es el stock del producto CAMP-001.
      
     b) Cuando hago esta consulta, la API busca en la base de datos en la tabla read.stock_view, el registro de SKU "CAMP-001". Y esto me devuelve la informacion en formato JSON
      <img width="544" height="76" alt="image" src="https://github.com/user-attachments/assets/385e6471-0a44-45cf-8ff6-d92dd7ab2bf0" />
     Este es un ejemplo antes de la venta, que nos demuestra es STOCK acutal del producto "Tienda de campa√±a".
   c)
   Ahora voy a correr un comando que representa la parte de escritura. 
   <img width="511" height="127" alt="image" src="https://github.com/user-attachments/assets/43b3d1f2-05d8-445d-be1a-e35a9cafdaa9" />
   Estoy dici√©ndole al sistema que se vendieron 3 unidades del producto CAMP-001 a un precio de 299.90 cada una.
   Y lo que pasa dentro del sistema es que:
   1Ô∏è. Command API (puerto 3001) recibe la venta.
   2Ô∏è. Actualiza el stock en la base de datos de escritura (write.stock).
   3Ô∏è. Registra la venta en write.sales.
   4Ô∏è. Guarda un evento llamado SaleCreated en la tabla write.outbox_events.
   5Ô∏è. El Projector detecta ese evento y actualiza la base de lectura (read.stock_view).
   6Ô∏è. Cuando luego haces:
<img width="558" height="116" alt="image" src="https://github.com/user-attachments/assets/9b3a687d-8ad2-4d9e-b749-402386d7453d" />
Baja de 110 a 107 unidades. 

6. Interpretaci√≥n del resultado

La demo muestra de manera pr√°ctica c√≥mo funciona el patr√≥n CQRS dentro de un entorno real basado en microservicios.
Se puede observar claramente la separaci√≥n entre:

-Escritura (Command API): cuando se ejecuta la venta (POST /ventas), el sistema actualiza el modelo de escritura y genera un evento.
-Sincronizaci√≥n (Projector): el evento SaleCreated es procesado autom√°ticamente, manteniendo actualizada la base de lectura sin afectar el rendimiento.
-Lectura (Query API): cuando se consulta el stock (GET /stock/CAMP-001), la informaci√≥n se obtiene desde el modelo de lectura optimizado (read.stock_view).

Este flujo demuestra el principio de consistencia eventual: el cambio no se refleja de inmediato, sino unos segundos despu√©s, garantizando que las operaciones sean r√°pidas y seguras.

Adem√°s, el uso de contenedores Docker permiti√≥ aislar los servicios y simular un entorno distribuido real, facilitando la comprensi√≥n de c√≥mo se comunican los distintos componentes de la arquitectura CQRS.

CODIGO REALIZADO: 
https://github.com/salcar420/Demo-Arqui.git



   
[‚¨ÖÔ∏è Anterior](../0.7.4/0.7.4.md) | [üè† Home](../../../README.md)
